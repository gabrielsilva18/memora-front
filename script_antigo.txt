// Configura√ß√µes globais
const CONFIG = {
    backendUrl: 'http://localhost:3000/api', // Ajuste conforme necess√°rio
    maxRecordingTime: 15000, // 60 segundos
    audioFormat: 'audio/webm;codecs=opus',
    audioPath: './public/' // Caminho para os arquivos de √°udio
};

// Mapeamento dos arquivos de √°udio
const AUDIO_FILES = {
    welcome: 'Bem_vindo.wav',
    listening: 'Estou_ouvindo.wav',
    repeat: 'Por_favor_repita.wav',
    reminderName: 'Qual_nome_do_lembrete.wav',
    reminderDate: 'que dia gostaria de ser lembrado.wav',
    reminderTime: 'que horas gostaria de ser lembrado.wav',
    reminderRepeat: 'este √© um lembrete que gostaria de repetir.wav',
    editReminder: 'me diga o nome do lemberte que deseja editar.wav',
    deleteReminder: 'me diga o nome do lemberte que deseja excluir.wav'
};

// Estado da aplica√ß√£o
let isRecording = false;
let mediaRecorder = null;
let audioChunks = [];
let currentStream = null;
let isMuted = false;
let isFirstTime = true;
let currentConversationState = 'welcome'; // Estado da conversa
let currentReminderData = {}; // Dados do lembrete sendo criado
let audioCache = new Map(); // Cache de √°udios para reprodu√ß√£o mais r√°pida

// Elementos DOM
const recordButton = document.getElementById('recordButton');
const statusIndicator = document.getElementById('status-indicator');
const feedbackContainer = document.getElementById('feedbackContainer');
const feedbackText = document.getElementById('feedbackText');
const muteButton = document.getElementById('muteButton');

// Inicializa√ß√£o
async function initializeApp() {
    updateStatus('üé§', 'ready');

    // Pr√©-carregar √°udios importantes
    await preloadImportantAudios();

    // Registrar desbloqueio de √°udio (para o caso do navegador bloquear autoplay)
    setupAudioUnlockOnce();

    // Tentativa autom√°tica de reprodu√ß√£o com fallback TTS
    try {
        console.log('Tentando tocar mensagem de boas-vindas automaticamente...');
        await speakWelcomeMessage();
        console.log('Mensagem de boas-vindas reproduzida com sucesso!');
        isFirstTime = false;
    } catch (err) {
        console.warn('‚ö†Ô∏è Autoplay bloqueado pelo navegador:', err);

        // üîÑ Fallback: usa TTS imediatamente
        await speakText(
            'Bem-vindo ao sistema de lembretes. ' +
            'Diga "criar lembrete" para criar um novo lembrete, ' +
            '"editar lembrete" para editar um lembrete existente, ' +
            'ou "excluir lembrete" para remover um lembrete.'
        );

        isFirstTime = false;
    }
}

// Pr√©-carregar √°udios importantes
async function preloadImportantAudios() {
    const importantAudios = ['welcome', 'listening', 'repeat'];
    
    for (const audioKey of importantAudios) {
        try {
            const audioFile = AUDIO_FILES[audioKey];
            if (audioFile) {
                const audio = new Audio(`${CONFIG.audioPath}${audioFile}`);
                audio.preload = 'auto';
                audio.volume = 0; // Silencioso durante pr√©-carregamento
                audioCache.set(audioKey, audio);
                
                // Aguardar carregamento
                await new Promise((resolve) => {
                    audio.oncanplaythrough = resolve;
                    audio.onerror = resolve;
                    audio.load();
                });
            }
        } catch (error) {
            console.warn('Erro ao pr√©-carregar √°udio:', audioKey, error);
        }
    }
}

// Configurar event listeners
function setupEventListeners() {
    // Bot√£o principal de grava√ß√£o
    recordButton.addEventListener('click', toggleRecording);
    
    // Bot√£o de controle de som
    muteButton.addEventListener('click', () => toggleMute());
    
    // Feedback visual para hover
    recordButton.addEventListener('mouseenter', () => {
        if (!isRecording) {
            recordButton.style.transform = 'translateY(-2px)';
        }
    });
    
    recordButton.addEventListener('mouseleave', () => {
        if (!isRecording) {
            recordButton.style.transform = 'translateY(0)';
        }
    });
}

// Verificar permiss√£o do microfone
async function checkMicrophonePermission() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop());
        console.log('Permiss√£o do microfone concedida');
    } catch (error) {
        console.error('Erro ao acessar microfone:', error);
        await speakText('Erro: Permiss√£o do microfone necess√°ria para usar o aplicativo.');
    }
}

// Fun√ß√£o para reproduzir √°udio personalizado
async function playAudio(audioKey, speed = 1.0) {
    if (isMuted) return;
    
    try {
        // Verificar se j√° est√° no cache
        let audio = audioCache.get(audioKey);
        
        if (!audio) {
            const audioFile = AUDIO_FILES[audioKey];
            if (!audioFile) {
                console.error('Arquivo de √°udio n√£o encontrado:', audioKey);
                return;
            }
            
            audio = new Audio(`${CONFIG.audioPath}${audioFile}`);
            audio.volume = 1;
            audio.playbackRate = speed;
            audio.preload = 'auto';
            audioCache.set(audioKey, audio);
        }
        
        // Clonar o √°udio para permitir reprodu√ß√£o simult√¢nea se necess√°rio
        const audioClone = audio.cloneNode();
        audioClone.volume = 1;
        audioClone.playbackRate = speed; // Aplicar velocidade
        
        return new Promise((resolve, reject) => {
            // Timeout reduzido para resposta mais r√°pida
            const timeout = setTimeout(() => {
                console.warn('Timeout na reprodu√ß√£o do √°udio:', audioKey);
                resolve();
            }, 5000); // 5 segundos timeout
            
            audioClone.onended = () => {
                clearTimeout(timeout);
                resolve();
            };
            
            audioClone.onerror = (error) => {
                clearTimeout(timeout);
                console.error('Erro ao reproduzir √°udio:', error);
                reject(error);
            };
            
            // Reproduzir imediatamente se j√° carregado
            if (audioClone.readyState >= 2) {
                audioClone.play().catch(error => {
                    clearTimeout(timeout);
                    console.error('Erro ao iniciar reprodu√ß√£o:', error);
                    reject(error);
                });
            } else {
                audioClone.oncanplaythrough = () => {
                    audioClone.play().catch(error => {
                        clearTimeout(timeout);
                        console.error('Erro ao iniciar reprodu√ß√£o:', error);
                        reject(error);
                    });
                };
                audioClone.load();
            }
        });
    } catch (error) {
        console.error('Erro na reprodu√ß√£o de √°udio:', error);
    }
}

// Fun√ß√£o para reproduzir √°udio com velocidade otimizada
async function playAudioFast(audioKey) {
    return await playAudio(audioKey, 1.2); // 20% mais r√°pido
}

// Fun√ß√£o para s√≠ntese de voz (fallback para casos n√£o mapeados)
async function speakText(text) {
    if (isMuted) return;
    
    try {
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'pt-BR';
            utterance.rate = 0.8;
            utterance.pitch = 1;
            utterance.volume = 1;
            
            speechSynthesis.speak(utterance);
        }
    } catch (error) {
        console.error('Erro na s√≠ntese de voz:', error);
    }
}

// Mensagem de boas-vindas
async function speakWelcomeMessage() {
    currentConversationState = 'welcome';
    try {
        // Usar velocidade ainda mais r√°pida para boas-vindas
        await playAudio('welcome', 1.4);
        // Ap√≥s boas-vindas, perguntar op√ß√µes dispon√≠veis
        setTimeout(async () => {
            await speakOptions();
        }, 2000);
    } catch (e) {
        // Caso bloqueado por autoplay, delegar para desbloqueio por gesto
        throw e;
    }
}

// Fun√ß√£o para falar op√ß√µes dispon√≠veis
async function speakOptions() {
    currentConversationState = 'listening';
    // N√£o falar op√ß√µes pois o √°udio de boas-vindas j√° cont√©m as op√ß√µes
    console.log('Sistema aguardando comando do usu√°rio...');
}

// Fun√ß√£o para processar resposta do usu√°rio
async function processUserResponse(audioBlob) {
    console.log('üé§ Iniciando processamento de √°udio...');
    
    // SEMPRE processar localmente primeiro (Local First)
    await processUserResponseLocal(audioBlob);
}

// Processamento local quando backend n√£o est√° dispon√≠vel
async function simulateLocalProcessing() {
    console.log('Backend n√£o dispon√≠vel, aguardando resposta do usu√°rio...');
    
    // Aguardar resposta real do usu√°rio - n√£o simular dados
    if (currentConversationState === 'welcome') {
        // Na tela inicial, simular "criar lembrete"
        await handleConversationFlow('create_reminder', {});
    } else {
        // Para outros estados, pedir para repetir (usu√°rio deve falar a informa√ß√£o real)
        await playAudioFast('repeat');
    }
}

// Fun√ß√£o para processar resposta do usu√°rio sem backend
async function processUserResponseLocal(audioBlob) {
    console.log('üé§ Processando √°udio do usu√°rio...', audioBlob.size, 'bytes');
    
    // Simular processamento de √°udio e extrair informa√ß√µes baseadas no estado atual
    const userResponse = await extractUserResponse(audioBlob);
    
    if (userResponse) {
        console.log('‚úÖ √Åudio processado com sucesso:', userResponse);
        await handleConversationFlow(userResponse.intent, userResponse.data);
    } else {
        console.log('‚ùå N√£o foi poss√≠vel processar o √°udio, pedindo para repetir...');
        // Se n√£o conseguir processar, pedir para repetir
        try {
            await playAudioFast('repeat');
        } catch (error) {
            console.log('Erro ao tocar √°udio de repeti√ß√£o, usando TTS');
            await speakText('Por favor, repita o que voc√™ disse.');
        }
    }
}

// Fun√ß√£o para extrair resposta do usu√°rio (reconhecimento de voz real)
// Fun√ß√£o para extrair resposta do usu√°rio (simula√ß√£o de reconhecimento de voz)
async function extractUserResponse(audioBlob) {
    ¬† ¬† console.log('üé§ Processando √°udio real do usu√°rio...', audioBlob.size, 'bytes');
    ¬† ¬† 
    ¬† ¬† // Simular delay de processamento realista
    ¬† ¬† await new Promise(resolve => setTimeout(resolve, 1500));
    ¬† ¬† 
    ¬† ¬† // **SIMULA√á√ÉO REALISTA:** Vamos for√ßar uma entrada para os testes
    ¬† ¬† // **Em produ√ß√£o, esta se√ß√£o seria substitu√≠da pela chamada √† API de STT**
    ¬† ¬† 
    ¬† ¬† // Voc√™ deve substituir este bloco de c√≥digo para usar seu motor de STT
    ¬† ¬† const recognizedText = prompt(`[STT Mock] Digite o que voc√™ disse agora (Estado: ${currentConversationState}):`);
    ¬† ¬† 
    ¬† ¬† if (!recognizedText) {
    ¬† ¬† ¬† ¬† console.log('‚ùå Nenhuma transcri√ß√£o retornada.');
    ¬† ¬† ¬† ¬† return null;
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† const text = recognizedText.toLowerCase().trim();
    ¬† ¬† 
    ¬† ¬† if (currentConversationState === 'listening') {
    ¬† ¬† ¬† ¬† if (text.includes('criar')) return { intent: 'create_reminder', data: {} };
    ¬† ¬† ¬† ¬† if (text.includes('editar')) return { intent: 'edit_reminder', data: {} };
    ¬† ¬† ¬† ¬† if (text.includes('excluir')) return { intent: 'delete_reminder', data: {} };
    ¬† ¬† ¬† ¬† return null; // N√£o entendeu a inten√ß√£o principal
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† // L√≥gica para Preenchimento de Formul√°rio
    ¬† ¬† if (currentConversationState === 'reminder_name') {
    ¬† ¬† ¬† ¬† // Neste ponto, o texto reconhecido √© o NOME do lembrete
    ¬† ¬† ¬† ¬† return { intent: 'reminder_name', data: { name: recognizedText } };
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† if (currentConversationState === 'reminder_date') {
    ¬† ¬† ¬† ¬† // A normaliza√ß√£o de data cuida do texto reconhecido
    ¬† ¬† ¬† ¬† return { intent: 'reminder_date', data: { date: text } };
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† if (currentConversationState === 'reminder_time') {
    ¬† ¬† ¬† ¬† // A normaliza√ß√£o de tempo cuida do texto reconhecido
    ¬† ¬† ¬† ¬† return { intent: 'reminder_time', data: { time: text } };
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† if (currentConversationState === 'reminder_repeat') {
    ¬† ¬† ¬† ¬† // Simular o booleano de repeti√ß√£o
    ¬† ¬† ¬† ¬† const repeat = text.includes('sim') || text.includes('quero');
    ¬† ¬† ¬† ¬† return { intent: 'reminder_repeat', data: { repeat: repeat } };
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† if (currentConversationState === 'reminder_days') {
    ¬† ¬† ¬† ¬† // Captura os dias mencionados no texto
    ¬† ¬† ¬† ¬† return { intent: 'reminder_days', data: { repeatDays: text.split(',').map(s => s.trim()) } };
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† // Para edi√ß√£o/exclus√£o, assume-se que o texto √© o nome do lembrete
    ¬† ¬† if (currentConversationState === 'edit_reminder_name' || currentConversationState === 'delete_reminder_name') {
    ¬† ¬† ¬† ¬† return { intent: currentConversationState === 'edit_reminder_name' ? 'edit_reminder_name' : 'delete_reminder_name', data: { name: recognizedText } };
    ¬† ¬† }
    ¬† ¬† 
    ¬† ¬† console.log('‚ùå N√£o foi poss√≠vel reconhecer a fala');
    ¬† ¬† return null;
    }

// Fun√ß√£o para gerenciar o fluxo da conversa
async function handleConversationFlow(intent, data) {
    switch (intent) {
        case 'create_reminder':
            // Tocar √°udio ANTES de definir o estado
            try {
                await playAudioFast('reminderName');
            } catch (error) {
                console.log('Erro ao tocar √°udio, usando TTS como fallback');
                await speakText('Qual √© o nome do lembrete?');
            }
            currentConversationState = 'reminder_name';
            currentReminderData = {};
            break;
            
        case 'edit_reminder':
            // Tocar √°udio ANTES de definir o estado
            try {
                await playAudioFast('editReminder');
            } catch (error) {
                console.log('Erro ao tocar √°udio, usando TTS como fallback');
                await speakText('Me diga o nome do lembrete que deseja editar');
            }
            currentConversationState = 'edit_reminder_name';
            break;
            
        case 'delete_reminder':
            // Tocar √°udio ANTES de definir o estado
            try {
                await playAudioFast('deleteReminder');
            } catch (error) {
                console.log('Erro ao tocar √°udio, usando TTS como fallback');
                await speakText('Me diga o nome do lembrete que deseja excluir');
            }
            currentConversationState = 'delete_reminder_name';
            break;
            
        case 'edit_reminder_name':
            // Processar edi√ß√£o do lembrete
            await speakText('Lembrete encontrado para edi√ß√£o. Funcionalidade de edi√ß√£o ser√° implementada no backend.');
            currentConversationState = 'welcome';
            setTimeout(() => {
                speakWelcomeMessage();
            }, 2000);
            break;
            
        case 'delete_reminder_name':
            // Processar exclus√£o do lembrete
            await speakText('Lembrete encontrado para exclus√£o. Funcionalidade de exclus√£o ser√° implementada no backend.');
            currentConversationState = 'welcome';
            setTimeout(() => {
                speakWelcomeMessage();
            }, 2000);
            break;
            
        case 'reminder_name':
            currentReminderData.name = data.name;
            console.log('‚úÖ Nome capturado:', data.name);
            console.log('üìù JSON atual:', JSON.stringify(currentReminderData, null, 2));
            // Tocar √°udio ANTES de definir o estado
            try {
                await playAudioFast('reminderDate');
            } catch (error) {
                console.log('Erro ao tocar √°udio, usando TTS como fallback');
                await speakText('Que dia gostaria de ser lembrado?');
            }
            currentConversationState = 'reminder_date';
            break;
            
        case 'reminder_date':
            currentReminderData.date = normalizeDatePt(data.date);
            console.log('‚úÖ Data capturada:', data.date, '‚Üí Normalizada:', currentReminderData.date);
            console.log('üìù JSON atual:', JSON.stringify(currentReminderData, null, 2));
            // Tocar √°udio ANTES de definir o estado
            try {
                await playAudioFast('reminderTime');
            } catch (error) {
                console.log('Erro ao tocar √°udio, usando TTS como fallback');
                await speakText('Que horas gostaria de ser lembrado?');
            }
            currentConversationState = 'reminder_time';
            break;
            
        case 'reminder_time':
            currentReminderData.time = normalizeTimePt(data.time);
            console.log('‚úÖ Hora capturada:', data.time, '‚Üí Normalizada:', currentReminderData.time);
            console.log('üìù JSON atual:', JSON.stringify(currentReminderData, null, 2));
            // Tocar √°udio ANTES de definir o estado
            try {
                await playAudioFast('reminderRepeat');
            } catch (error) {
                console.log('Erro ao tocar √°udio, usando TTS como fallback');
                await speakText('Este √© um lembrete que gostaria de repetir?');
            }
            currentConversationState = 'reminder_repeat';
            break;
            
        case 'reminder_repeat':
            currentReminderData.repeat = data.repeat;
            console.log('‚úÖ Repetir capturado:', data.repeat);
            console.log('üìù JSON atual:', JSON.stringify(currentReminderData, null, 2));
            if (data.repeat === true) {
                // Perguntar dias da semana via TTS (n√£o h√° √°udio pronto espec√≠fico)
                currentConversationState = 'reminder_days';
                await speakText('Quais dias da semana deseja repetir? Diga: segunda, ter√ßa, quarta, quinta, sexta, s√°bado ou domingo.');
            } else {
                // Salvar lembrete completo
                await saveReminder();
            }
            break;
        
        case 'reminder_days':
            // Espera-se que data.repeatDays seja um array de strings
            currentReminderData.repeatDays = normalizeWeekdaysPt(data.repeatDays);
            console.log('‚úÖ Dias capturados:', data.repeatDays, '‚Üí Normalizados:', currentReminderData.repeatDays);
            console.log('üìù JSON atual:', JSON.stringify(currentReminderData, null, 2));
            await saveReminder();
            break;
            
        case 'list_reminders':
            // Listar lembretes existentes
            await listReminders();
            break;
            
        default:
            await playAudioFast('repeat');
            break;
    }
}

// Fun√ß√£o para validar se lembrete est√° completo
function isReminderComplete() {
    const required = ['name', 'date', 'time', 'repeat'];
    const hasRequired = required.every(field => currentReminderData[field] !== undefined);
    
    // Se quer repetir, precisa ter os dias da semana
    if (currentReminderData.repeat === true) {
        return hasRequired && Array.isArray(currentReminderData.repeatDays) && currentReminderData.repeatDays.length > 0;
    }
    
    return hasRequired;
}

// Fun√ß√£o para salvar lembrete completo
async function saveReminder() {
    // Validar se todas as informa√ß√µes est√£o completas
    if (!isReminderComplete()) {
        console.log('‚ùå Lembrete incompleto, aguardando mais informa√ß√µes:', currentReminderData);
        await speakText('Ainda faltam informa√ß√µes. Por favor, complete todos os dados do lembrete.');
        return;
    }
    
    try {
        console.log('üì§ Enviando lembrete completo ao backend:', currentReminderData);
        
        const response = await fetch(`${CONFIG.backendUrl}/reminders`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(currentReminderData)
        });
        
        if (response.ok) {
            console.log('‚úÖ Lembrete salvo com sucesso no backend!');
            await speakText('Lembrete salvo com sucesso!');
            currentConversationState = 'welcome';
            currentReminderData = {};
            // N√£o tocar boas-vindas novamente, apenas voltar ao estado inicial
        } else {
            console.log('‚ùå Erro do servidor:', response.status);
            await playAudioFast('repeat');
        }
    } catch (error) {
        console.error('‚ùå Erro ao salvar lembrete:', error);
        // Backend futuro indispon√≠vel: mostrar JSON completo para integra√ß√£o
        console.log('=== JSON COMPLETO PARA BACKEND ===');
        console.log(JSON.stringify(currentReminderData, null, 2));
        console.log('=== FIM DO JSON ===');
        await speakText('Seu lembrete est√° completo e pronto para ser enviado quando o servidor estiver dispon√≠vel.');
        currentConversationState = 'welcome';
        currentReminderData = {};
        // N√£o tocar boas-vindas novamente, apenas voltar ao estado inicial
    }
}

// Fun√ß√£o para listar lembretes
async function listReminders() {
    try {
        const response = await fetch(`${CONFIG.backendUrl}/reminders`);
        if (response.ok) {
            const reminders = await response.json();
            if (reminders.length > 0) {
                await speakText(`Voc√™ tem ${reminders.length} lembrete(s) cadastrado(s)`);
            } else {
                await speakText('Nenhum lembrete encontrado');
            }
        }
        currentConversationState = 'welcome';
        setTimeout(() => {
            speakWelcomeMessage();
        }, 2000);
    } catch (error) {
        console.error('Erro ao listar lembretes:', error);
        await playAudioFast('repeat');
    }
}

// Alternar grava√ß√£o
async function toggleRecording() {
    if (isRecording) {
        stopRecording();
    } else {
        await startRecording();
    }
}

// Iniciar grava√ß√£o
async function startRecording() {
    try {
        updateStatus('üî¥', 'recording');
        await playAudioFast('listening');
        
        // Obter stream de √°udio
        currentStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                sampleRate: 44100
            } 
        });
        
        // Configurar MediaRecorder
        mediaRecorder = new MediaRecorder(currentStream, {
            mimeType: CONFIG.audioFormat
        });
        
        audioChunks = [];
        
        // Event listeners para MediaRecorder
        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                audioChunks.push(event.data);
            }
        };
        
        mediaRecorder.onstop = () => {
            processRecording();
        };
        
        mediaRecorder.onerror = (error) => {
            console.error('Erro na grava√ß√£o:', error);
            playAudioFast('repeat');
            resetRecordingState();
        };
        
        // Iniciar grava√ß√£o
        mediaRecorder.start(1000); // Coletar dados a cada segundo
        isRecording = true;
        
        // Atualizar interface
        recordButton.classList.add('recording');
        recordButton.querySelector('.button-icon').textContent = '‚èπÔ∏è';
        
        // Timeout de seguran√ßa
        setTimeout(() => {
            if (isRecording) {
                stopRecording();
            }
        }, CONFIG.maxRecordingTime);
        
    } catch (error) {
        console.error('Erro ao iniciar grava√ß√£o:', error);
        await playAudioFast('repeat');
        resetRecordingState();
    }
}

// Parar grava√ß√£o
function stopRecording() {
    if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        
        // Parar stream
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
        }
        
        // Atualizar interface
        recordButton.classList.remove('recording');
        recordButton.querySelector('.button-icon').textContent = 'üé§';
        
        updateStatus('‚è≥', 'processing');
    }
}

// Processar grava√ß√£o
async function processRecording() {
    try {
        const audioBlob = new Blob(audioChunks, { type: CONFIG.audioFormat });
        
        if (audioBlob.size === 0) {
            await playAudioFast('repeat');
            resetRecordingState();
            return;
        }
        
        // Processar resposta do usu√°rio
        await processUserResponse(audioBlob);
        
    } catch (error) {
        console.error('Erro ao processar grava√ß√£o:', error);
        await playAudioFast('repeat');
        resetRecordingState();
    }
}

// Fun√ß√£o removida - agora usamos processUserResponse

// Reproduzir resposta de √°udio
function playAudioResponse(audioUrl) {
    try {
        const audio = new Audio(audioUrl);
        audio.play().catch(error => {
            console.error('Erro ao reproduzir √°udio:', error);
        });
    } catch (error) {
        console.error('Erro ao criar elemento de √°udio:', error);
    }
}

// Resetar estado da grava√ß√£o
function resetRecordingState() {
    isRecording = false;
    mediaRecorder = null;
    audioChunks = [];
    currentStream = null;
    
    recordButton.classList.remove('recording');
    recordButton.querySelector('.button-icon').textContent = 'üé§';
    
    updateStatus('üé§', 'ready');
}

// Atualizar status
function updateStatus(text, type = 'ready') {
    statusIndicator.querySelector('.status-text').textContent = text;
    statusIndicator.className = `status-indicator ${type}`;
}

// Mostrar feedback (minimalista)
function showFeedback(message, type = 'info') {
    feedbackText.textContent = message;
    feedbackText.className = `feedback-text ${type}`;
    
    // Auto-hide ap√≥s 3 segundos
    setTimeout(() => {
        feedbackText.textContent = '';
        feedbackText.className = 'feedback-text';
    }, 3000);
}

// Alternar silenciar
function toggleMute() {
    isMuted = !isMuted;
    
    if (isMuted) {
        muteButton.querySelector('.button-icon').textContent = 'üîá';
        muteButton.classList.add('muted');
        // N√£o falar ao desativar para evitar sil√™ncio permanente
    } else {
        muteButton.querySelector('.button-icon').textContent = 'üîä';
        muteButton.classList.remove('muted');
        // Falar curto ao reativar
        speakText('Som ativado');
    }
}

// Utilit√°rios
function formatTime(date) {
    return new Intl.DateTimeFormat('pt-BR', {
        hour: '2-digit',
        minute: '2-digit',
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    }).format(date);
}

// Tratamento de erros global
window.addEventListener('error', async (event) => {
    console.error('Erro global:', event.error);
    await playAudioFast('repeat');
});

// Tratamento de erros n√£o capturados
window.addEventListener('unhandledrejection', async (event) => {
    console.error('Promise rejeitada:', event.reason);
    await playAudioFast('repeat');
});

// Desbloqueio de √°udio no primeiro gesto do usu√°rio (para contornar autoplay)
function setupAudioUnlockOnce() {
    const unlockAndGreet = async () => {
        if (isFirstTime) {
            try {
                console.log('Desbloqueando √°udio no primeiro gesto...');
                await speakWelcomeMessage();
                isFirstTime = false;
            } catch (e) {
                console.log('Erro ao tocar boas-vindas ap√≥s desbloqueio:', e);
            } finally {
                // Remover listeners ap√≥s primeira execu√ß√£o
                document.removeEventListener('click', unlockAndGreet);
                document.removeEventListener('touchstart', unlockAndGreet);
                document.removeEventListener('keydown', unlockAndGreet);
            }
        }
    };
    
    // S√≥ adicionar listeners se ainda for primeira vez
    if (isFirstTime) {
        document.addEventListener('click', unlockAndGreet, { once: true });
        document.addEventListener('touchstart', unlockAndGreet, { once: true });
        document.addEventListener('keydown', unlockAndGreet, { once: true });
    }
}


// =========================
// Normaliza√ß√£o PT-BR -> ISO
// =========================
function normalizeTimePt(input) {
    if (!input) return input;
    let text = String(input).toLowerCase().trim();
    
    // Extrair horas e minutos de formatos como "15 horas e 20 minutos"
    const timeMatch = text.match(/(\d{1,2})\s*(?:horas?|h)\s*(?:e\s*(\d{1,2})\s*(?:minutos?|min))?/);
    if (timeMatch) {
        let hour = parseInt(timeMatch[1], 10);
        let minute = timeMatch[2] ? parseInt(timeMatch[2], 10) : 0;
        
        // Validar e formatar
        hour = Math.max(0, Math.min(23, hour));
        minute = Math.max(0, Math.min(59, minute));
        
        const hh = String(hour).padStart(2, '0');
        const mm = String(minute).padStart(2, '0');
        return `${hh}:${mm}`;
    }
    
    // Fallback para formato original
    text = text
        .replace(/\s+/g, ' ')
        .replace(/horas?|h/gi, '')
        .replace(/da\s*manh√£|da\s*manha/gi, 'manha')
        .replace(/da\s*noite/gi, 'noite')
        .replace(/da\s*tarde/gi, 'tarde')
        .trim();

    // Extrair n√∫mero(s)
    const match = text.match(/(\d{1,2})(?:[:h](\d{1,2}))?/);
    if (!match) return input;
    let hour = parseInt(match[1], 10);
    let minute = match[2] ? parseInt(match[2], 10) : 0;

    const hasManha = /manha/.test(text);
    const hasTarde = /tarde/.test(text);
    const hasNoite = /noite/.test(text);

    // Regras 12/24h em PT:
    if (hasManha) {
        if (hour === 12) hour = 0;
        if (hour > 23) hour = hour % 24;
    } else if (hasTarde || hasNoite) {
        if (hour >= 1 && hour <= 11) hour += 12;
        if (hour > 23) hour = hour % 24;
    } else {
        // sem per√≠odo, tratar como 24h v√°lida
        if (hour > 23) hour = hour % 24;
    }

    const hh = String(Math.max(0, Math.min(23, hour))).padStart(2, '0');
    const mm = String(Math.max(0, Math.min(59, minute))).padStart(2, '0');
    return `${hh}:${mm}`;
}

function normalizeDatePt(input) {
    if (!input) return input;
    const text = String(input).toLowerCase().trim();
    
    // Mapear meses em portugu√™s
    const monthMap = {
        'janeiro': 1, 'fevereiro': 2, 'mar√ßo': 3, 'abril': 4, 'maio': 5, 'junho': 6,
        'julho': 7, 'agosto': 8, 'setembro': 9, 'outubro': 10, 'novembro': 11, 'dezembro': 12
    };
    
    // Extrair dia e m√™s
    const dayMatch = text.match(/(\d{1,2})/);
    const monthMatch = text.match(/(janeiro|fevereiro|mar√ßo|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/);
    
    if (dayMatch && monthMatch) {
        const day = parseInt(dayMatch[1], 10);
        const month = monthMap[monthMatch[1]];
        const year = new Date().getFullYear();
        
        // Criar data
        const date = new Date(year, month - 1, day);
        const yyyy = date.getFullYear();
        const mm = String(date.getMonth() + 1).padStart(2, '0');
        const dd = String(date.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }
    
    // Fallback para formato simples "dia X"
    const simpleMatch = text.match(/(\d{1,2})/);
    if (simpleMatch) {
        const now = new Date();
        const day = parseInt(simpleMatch[1], 10);
        const year = now.getFullYear();
        const month = now.getMonth();
        const d = new Date(year, month, day);
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }
    
    return input;
}

function normalizeWeekdaysPt(list) {
    if (!Array.isArray(list)) return [];
    const map = {
        'segunda': 'monday', 'segunda-feira': 'monday',
        'terca': 'tuesday', 'ter√ßa': 'tuesday', 'ter√ßa-feira': 'tuesday', 'terca-feira': 'tuesday',
        'quarta': 'wednesday', 'quarta-feira': 'wednesday',
        'quinta': 'thursday', 'quinta-feira': 'thursday',
        'sexta': 'friday', 'sexta-feira': 'friday',
        'sabado': 'saturday', 's√°bado': 'saturday',
        'domingo': 'sunday'
    };
    const normalized = [];
    for (const item of list) {
        if (!item) continue;
        const key = String(item).toLowerCase().trim();
        const k2 = key.normalize('NFD').replace(/\p{Diacritic}/gu, '');
        const value = map[key] || map[k2];
        if (value && !normalized.includes(value)) normalized.push(value);
    }
    return normalized;
}
